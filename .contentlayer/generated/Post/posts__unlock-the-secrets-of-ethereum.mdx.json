{
  "title": "Unlock the Secrets of Ethereum, How the EVM Memory Maze Can Make or Break Your Smart Contracts!",
  "description": "The Ethereum Virtual Machine (EVM) is a crucial component of the Ethereum network, responsible for executing smart contracts and maintaining the state of the Ethereum blockchain. When it comes to the memory location in the context of the EVM, it's important to understand how the EVM handles data and storage.",
  "date": "2024-02-19T00:00:00.000Z",
  "body": {
    "raw": "The Ethereum Virtual Machine (EVM) is a crucial component of the Ethereum network, responsible for executing smart contracts and maintaining the state of the Ethereum blockchain. When it comes to the memory location in the context of the EVM, it's important to understand how the EVM handles data and storage.\n## Memory in the EVM\nThe EVM has a volatile memory space where data can be stored temporarily during the execution of a smart contract. This memory is akin to the RAM in a computer. It is created afresh for each transaction and gets erased after the transaction is completed. This memory is linear and can be expanded as needed by the smart contract during its execution, but it cannot persist data between transactions.\n\n## Storage in the EVM\nIn contrast to memory, storage in the EVM is non-volatile and is used to store the state of smart contracts. This is akin to a computer's hard drive. Each smart contract deployed on the Ethereum network has its own storage space, where it can store data persistently. Unlike memory, storage data remains intact between transactions and is written to the Ethereum blockchain, making it permanent and unchangeable (unless modified by the smart contract's code).\n\n## Stack in the EVM\nThe EVM also has a stack, which is used for evaluations and control flow. The stack has a maximum size of 1024 elements and is used for performing operations like adding, multiplying, and so on. Data can be pushed to or popped from the stack during the execution of a smart contract.\n\n## Gas Costs\nIt's important to note that both memory and storage operations in the EVM come with associated gas costs. Gas is the fee required to conduct a transaction or execute a smart contract on the Ethereum network. Operations involving storage are generally more expensive than those involving memory due to the permanent nature of storage.\n\n## Blockchain State\nThe overall state of the Ethereum blockchain (including all account balances, smart contract code, and smart contract storage) is stored in a data structure known as a Merkle Patricia Tree. This structure enables efficient and secure verification of the blockchain's contents.\n\nIn summary, the EVM's memory location refers to the volatile space used for temporary data storage during transaction execution, while persistent data storage is achieved through the blockchain's state, specifically in the storage associated with each smart contract. The EVM's architecture ensures efficient execution of smart contracts while maintaining the integrity and state of the Ethereum blockchain.",
    "code": "var Component=(()=>{var cr=Object.create;var D=Object.defineProperty;var ur=Object.getOwnPropertyDescriptor;var lr=Object.getOwnPropertyNames;var fr=Object.getPrototypeOf,dr=Object.prototype.hasOwnProperty;var z=(u,a)=>()=>(a||u((a={exports:{}}).exports,a),a.exports),br=(u,a)=>{for(var p in a)D(u,p,{get:a[p],enumerable:!0})},Ee=(u,a,p,_)=>{if(a&&typeof a==\"object\"||typeof a==\"function\")for(let y of lr(a))!dr.call(u,y)&&y!==p&&D(u,y,{get:()=>a[y],enumerable:!(_=ur(a,y))||_.enumerable});return u};var hr=(u,a,p)=>(p=u!=null?cr(fr(u)):{},Ee(a||!u||!u.__esModule?D(p,\"default\",{value:u,enumerable:!0}):p,u)),mr=u=>Ee(D({},\"__esModule\",{value:!0}),u);var xe=z((Er,Re)=>{Re.exports=React});var Te=z(q=>{\"use strict\";(function(){\"use strict\";var u=xe(),a=Symbol.for(\"react.element\"),p=Symbol.for(\"react.portal\"),_=Symbol.for(\"react.fragment\"),y=Symbol.for(\"react.strict_mode\"),X=Symbol.for(\"react.profiler\"),H=Symbol.for(\"react.provider\"),K=Symbol.for(\"react.context\"),C=Symbol.for(\"react.forward_ref\"),F=Symbol.for(\"react.suspense\"),V=Symbol.for(\"react.suspense_list\"),S=Symbol.for(\"react.memo\"),A=Symbol.for(\"react.lazy\"),Se=Symbol.for(\"react.offscreen\"),J=Symbol.iterator,Oe=\"@@iterator\";function Pe(e){if(e===null||typeof e!=\"object\")return null;var r=J&&e[J]||e[Oe];return typeof r==\"function\"?r:null}var R=u.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;function b(e){{for(var r=arguments.length,t=new Array(r>1?r-1:0),n=1;n<r;n++)t[n-1]=arguments[n];Ne(\"error\",e,t)}}function Ne(e,r,t){{var n=R.ReactDebugCurrentFrame,s=n.getStackAddendum();s!==\"\"&&(r+=\"%s\",t=t.concat([s]));var c=t.map(function(i){return String(i)});c.unshift(\"Warning: \"+r),Function.prototype.apply.call(console[e],console,c)}}var je=!1,Me=!1,De=!1,Fe=!1,Ve=!1,Z;Z=Symbol.for(\"react.module.reference\");function Ae(e){return!!(typeof e==\"string\"||typeof e==\"function\"||e===_||e===X||Ve||e===y||e===F||e===V||Fe||e===Se||je||Me||De||typeof e==\"object\"&&e!==null&&(e.$$typeof===A||e.$$typeof===S||e.$$typeof===H||e.$$typeof===K||e.$$typeof===C||e.$$typeof===Z||e.getModuleId!==void 0))}function Ue(e,r,t){var n=e.displayName;if(n)return n;var s=r.displayName||r.name||\"\";return s!==\"\"?t+\"(\"+s+\")\":t}function Q(e){return e.displayName||\"Context\"}function v(e){if(e==null)return null;if(typeof e.tag==\"number\"&&b(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"),typeof e==\"function\")return e.displayName||e.name||null;if(typeof e==\"string\")return e;switch(e){case _:return\"Fragment\";case p:return\"Portal\";case X:return\"Profiler\";case y:return\"StrictMode\";case F:return\"Suspense\";case V:return\"SuspenseList\"}if(typeof e==\"object\")switch(e.$$typeof){case K:var r=e;return Q(r)+\".Consumer\";case H:var t=e;return Q(t._context)+\".Provider\";case C:return Ue(e,e.render,\"ForwardRef\");case S:var n=e.displayName||null;return n!==null?n:v(e.type)||\"Memo\";case A:{var s=e,c=s._payload,i=s._init;try{return v(i(c))}catch{return null}}}return null}var E=Object.assign,w=0,ee,re,te,ne,ae,oe,ie;function se(){}se.__reactDisabledLog=!0;function Ie(){{if(w===0){ee=console.log,re=console.info,te=console.warn,ne=console.error,ae=console.group,oe=console.groupCollapsed,ie=console.groupEnd;var e={configurable:!0,enumerable:!0,value:se,writable:!0};Object.defineProperties(console,{info:e,log:e,warn:e,error:e,group:e,groupCollapsed:e,groupEnd:e})}w++}}function We(){{if(w--,w===0){var e={configurable:!0,enumerable:!0,writable:!0};Object.defineProperties(console,{log:E({},e,{value:ee}),info:E({},e,{value:re}),warn:E({},e,{value:te}),error:E({},e,{value:ne}),group:E({},e,{value:ae}),groupCollapsed:E({},e,{value:oe}),groupEnd:E({},e,{value:ie})})}w<0&&b(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\")}}var U=R.ReactCurrentDispatcher,I;function O(e,r,t){{if(I===void 0)try{throw Error()}catch(s){var n=s.stack.trim().match(/\\n( *(at )?)/);I=n&&n[1]||\"\"}return`\n`+I+e}}var W=!1,P;{var Ye=typeof WeakMap==\"function\"?WeakMap:Map;P=new Ye}function ce(e,r){if(!e||W)return\"\";{var t=P.get(e);if(t!==void 0)return t}var n;W=!0;var s=Error.prepareStackTrace;Error.prepareStackTrace=void 0;var c;c=U.current,U.current=null,Ie();try{if(r){var i=function(){throw Error()};if(Object.defineProperty(i.prototype,\"props\",{set:function(){throw Error()}}),typeof Reflect==\"object\"&&Reflect.construct){try{Reflect.construct(i,[])}catch(g){n=g}Reflect.construct(e,[],i)}else{try{i.call()}catch(g){n=g}e.call(i.prototype)}}else{try{throw Error()}catch(g){n=g}e()}}catch(g){if(g&&n&&typeof g.stack==\"string\"){for(var o=g.stack.split(`\n`),h=n.stack.split(`\n`),l=o.length-1,f=h.length-1;l>=1&&f>=0&&o[l]!==h[f];)f--;for(;l>=1&&f>=0;l--,f--)if(o[l]!==h[f]){if(l!==1||f!==1)do if(l--,f--,f<0||o[l]!==h[f]){var m=`\n`+o[l].replace(\" at new \",\" at \");return e.displayName&&m.includes(\"<anonymous>\")&&(m=m.replace(\"<anonymous>\",e.displayName)),typeof e==\"function\"&&P.set(e,m),m}while(l>=1&&f>=0);break}}}finally{W=!1,U.current=c,We(),Error.prepareStackTrace=s}var T=e?e.displayName||e.name:\"\",_e=T?O(T):\"\";return typeof e==\"function\"&&P.set(e,_e),_e}function $e(e,r,t){return ce(e,!1)}function Le(e){var r=e.prototype;return!!(r&&r.isReactComponent)}function N(e,r,t){if(e==null)return\"\";if(typeof e==\"function\")return ce(e,Le(e));if(typeof e==\"string\")return O(e);switch(e){case F:return O(\"Suspense\");case V:return O(\"SuspenseList\")}if(typeof e==\"object\")switch(e.$$typeof){case C:return $e(e.render);case S:return N(e.type,r,t);case A:{var n=e,s=n._payload,c=n._init;try{return N(c(s),r,t)}catch{}}}return\"\"}var j=Object.prototype.hasOwnProperty,ue={},le=R.ReactDebugCurrentFrame;function M(e){if(e){var r=e._owner,t=N(e.type,e._source,r?r.type:null);le.setExtraStackFrame(t)}else le.setExtraStackFrame(null)}function Be(e,r,t,n,s){{var c=Function.call.bind(j);for(var i in e)if(c(e,i)){var o=void 0;try{if(typeof e[i]!=\"function\"){var h=Error((n||\"React class\")+\": \"+t+\" type `\"+i+\"` is invalid; it must be a function, usually from the `prop-types` package, but received `\"+typeof e[i]+\"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");throw h.name=\"Invariant Violation\",h}o=e[i](r,i,n,t,null,\"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\")}catch(l){o=l}o&&!(o instanceof Error)&&(M(s),b(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\",n||\"React class\",t,i,typeof o),M(null)),o instanceof Error&&!(o.message in ue)&&(ue[o.message]=!0,M(s),b(\"Failed %s type: %s\",t,o.message),M(null))}}}var Ge=Array.isArray;function Y(e){return Ge(e)}function ze(e){{var r=typeof Symbol==\"function\"&&Symbol.toStringTag,t=r&&e[Symbol.toStringTag]||e.constructor.name||\"Object\";return t}}function qe(e){try{return fe(e),!1}catch{return!0}}function fe(e){return\"\"+e}function de(e){if(qe(e))return b(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\",ze(e)),fe(e)}var k=R.ReactCurrentOwner,Xe={key:!0,ref:!0,__self:!0,__source:!0},be,he,$;$={};function He(e){if(j.call(e,\"ref\")){var r=Object.getOwnPropertyDescriptor(e,\"ref\").get;if(r&&r.isReactWarning)return!1}return e.ref!==void 0}function Ke(e){if(j.call(e,\"key\")){var r=Object.getOwnPropertyDescriptor(e,\"key\").get;if(r&&r.isReactWarning)return!1}return e.key!==void 0}function Je(e,r){if(typeof e.ref==\"string\"&&k.current&&r&&k.current.stateNode!==r){var t=v(k.current.type);$[t]||(b('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref',v(k.current.type),e.ref),$[t]=!0)}}function Ze(e,r){{var t=function(){be||(be=!0,b(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\",r))};t.isReactWarning=!0,Object.defineProperty(e,\"key\",{get:t,configurable:!0})}}function Qe(e,r){{var t=function(){he||(he=!0,b(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\",r))};t.isReactWarning=!0,Object.defineProperty(e,\"ref\",{get:t,configurable:!0})}}var er=function(e,r,t,n,s,c,i){var o={$$typeof:a,type:e,key:r,ref:t,props:i,_owner:c};return o._store={},Object.defineProperty(o._store,\"validated\",{configurable:!1,enumerable:!1,writable:!0,value:!1}),Object.defineProperty(o,\"_self\",{configurable:!1,enumerable:!1,writable:!1,value:n}),Object.defineProperty(o,\"_source\",{configurable:!1,enumerable:!1,writable:!1,value:s}),Object.freeze&&(Object.freeze(o.props),Object.freeze(o)),o};function rr(e,r,t,n,s){{var c,i={},o=null,h=null;t!==void 0&&(de(t),o=\"\"+t),Ke(r)&&(de(r.key),o=\"\"+r.key),He(r)&&(h=r.ref,Je(r,s));for(c in r)j.call(r,c)&&!Xe.hasOwnProperty(c)&&(i[c]=r[c]);if(e&&e.defaultProps){var l=e.defaultProps;for(c in l)i[c]===void 0&&(i[c]=l[c])}if(o||h){var f=typeof e==\"function\"?e.displayName||e.name||\"Unknown\":e;o&&Ze(i,f),h&&Qe(i,f)}return er(e,o,h,s,n,k.current,i)}}var L=R.ReactCurrentOwner,me=R.ReactDebugCurrentFrame;function x(e){if(e){var r=e._owner,t=N(e.type,e._source,r?r.type:null);me.setExtraStackFrame(t)}else me.setExtraStackFrame(null)}var B;B=!1;function G(e){return typeof e==\"object\"&&e!==null&&e.$$typeof===a}function pe(){{if(L.current){var e=v(L.current.type);if(e)return`\n\nCheck the render method of \\``+e+\"`.\"}return\"\"}}function tr(e){{if(e!==void 0){var r=e.fileName.replace(/^.*[\\\\\\/]/,\"\"),t=e.lineNumber;return`\n\nCheck your code at `+r+\":\"+t+\".\"}return\"\"}}var ve={};function nr(e){{var r=pe();if(!r){var t=typeof e==\"string\"?e:e.displayName||e.name;t&&(r=`\n\nCheck the top-level render call using <`+t+\">.\")}return r}}function ge(e,r){{if(!e._store||e._store.validated||e.key!=null)return;e._store.validated=!0;var t=nr(r);if(ve[t])return;ve[t]=!0;var n=\"\";e&&e._owner&&e._owner!==L.current&&(n=\" It was passed a child from \"+v(e._owner.type)+\".\"),x(e),b('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.',t,n),x(null)}}function ye(e,r){{if(typeof e!=\"object\")return;if(Y(e))for(var t=0;t<e.length;t++){var n=e[t];G(n)&&ge(n,r)}else if(G(e))e._store&&(e._store.validated=!0);else if(e){var s=Pe(e);if(typeof s==\"function\"&&s!==e.entries)for(var c=s.call(e),i;!(i=c.next()).done;)G(i.value)&&ge(i.value,r)}}}function ar(e){{var r=e.type;if(r==null||typeof r==\"string\")return;var t;if(typeof r==\"function\")t=r.propTypes;else if(typeof r==\"object\"&&(r.$$typeof===C||r.$$typeof===S))t=r.propTypes;else return;if(t){var n=v(r);Be(t,e.props,\"prop\",n,e)}else if(r.PropTypes!==void 0&&!B){B=!0;var s=v(r);b(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\",s||\"Unknown\")}typeof r.getDefaultProps==\"function\"&&!r.getDefaultProps.isReactClassApproved&&b(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\")}}function or(e){{for(var r=Object.keys(e.props),t=0;t<r.length;t++){var n=r[t];if(n!==\"children\"&&n!==\"key\"){x(e),b(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\",n),x(null);break}}e.ref!==null&&(x(e),b(\"Invalid attribute `ref` supplied to `React.Fragment`.\"),x(null))}}function ir(e,r,t,n,s,c){{var i=Ae(e);if(!i){var o=\"\";(e===void 0||typeof e==\"object\"&&e!==null&&Object.keys(e).length===0)&&(o+=\" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");var h=tr(s);h?o+=h:o+=pe();var l;e===null?l=\"null\":Y(e)?l=\"array\":e!==void 0&&e.$$typeof===a?(l=\"<\"+(v(e.type)||\"Unknown\")+\" />\",o=\" Did you accidentally export a JSX literal instead of a component?\"):l=typeof e,b(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\",l,o)}var f=rr(e,r,t,s,c);if(f==null)return f;if(i){var m=r.children;if(m!==void 0)if(n)if(Y(m)){for(var T=0;T<m.length;T++)ye(m[T],e);Object.freeze&&Object.freeze(m)}else b(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");else ye(m,e)}return e===_?or(f):ar(f),f}}var sr=ir;q.Fragment=_,q.jsxDEV=sr})()});var ke=z((xr,we)=>{\"use strict\";we.exports=Te()});var yr={};br(yr,{default:()=>gr,frontmatter:()=>pr});var d=hr(ke()),pr={title:\"Unlock the Secrets of Ethereum, How the EVM Memory Maze Can Make or Break Your Smart Contracts!\",description:\"The Ethereum Virtual Machine (EVM) is a crucial component of the Ethereum network, responsible for executing smart contracts and maintaining the state of the Ethereum blockchain. When it comes to the memory location in the context of the EVM, it's important to understand how the EVM handles data and storage.\",date:\"Sun Feb 18 2024 19:00:00 GMT-0500 (Eastern Standard Time)\"};function Ce(u){let a=Object.assign({p:\"p\",h2:\"h2\"},u.components);return(0,d.jsxDEV)(d.Fragment,{children:[(0,d.jsxDEV)(a.p,{children:\"The Ethereum Virtual Machine (EVM) is a crucial component of the Ethereum network, responsible for executing smart contracts and maintaining the state of the Ethereum blockchain. When it comes to the memory location in the context of the EVM, it's important to understand how the EVM handles data and storage.\"},void 0,!1,{fileName:\"/Users/ryan/ryan-drachenberg/content/posts/_mdx_bundler_entry_point-90eec5be-c1fb-41fa-9d5b-e22b8abc8366.mdx\",lineNumber:6,columnNumber:1},this),`\n`,(0,d.jsxDEV)(a.h2,{children:\"Memory in the EVM\"},void 0,!1,{fileName:\"/Users/ryan/ryan-drachenberg/content/posts/_mdx_bundler_entry_point-90eec5be-c1fb-41fa-9d5b-e22b8abc8366.mdx\",lineNumber:7,columnNumber:1},this),`\n`,(0,d.jsxDEV)(a.p,{children:\"The EVM has a volatile memory space where data can be stored temporarily during the execution of a smart contract. This memory is akin to the RAM in a computer. It is created afresh for each transaction and gets erased after the transaction is completed. This memory is linear and can be expanded as needed by the smart contract during its execution, but it cannot persist data between transactions.\"},void 0,!1,{fileName:\"/Users/ryan/ryan-drachenberg/content/posts/_mdx_bundler_entry_point-90eec5be-c1fb-41fa-9d5b-e22b8abc8366.mdx\",lineNumber:8,columnNumber:1},this),`\n`,(0,d.jsxDEV)(a.h2,{children:\"Storage in the EVM\"},void 0,!1,{fileName:\"/Users/ryan/ryan-drachenberg/content/posts/_mdx_bundler_entry_point-90eec5be-c1fb-41fa-9d5b-e22b8abc8366.mdx\",lineNumber:10,columnNumber:1},this),`\n`,(0,d.jsxDEV)(a.p,{children:\"In contrast to memory, storage in the EVM is non-volatile and is used to store the state of smart contracts. This is akin to a computer's hard drive. Each smart contract deployed on the Ethereum network has its own storage space, where it can store data persistently. Unlike memory, storage data remains intact between transactions and is written to the Ethereum blockchain, making it permanent and unchangeable (unless modified by the smart contract's code).\"},void 0,!1,{fileName:\"/Users/ryan/ryan-drachenberg/content/posts/_mdx_bundler_entry_point-90eec5be-c1fb-41fa-9d5b-e22b8abc8366.mdx\",lineNumber:11,columnNumber:1},this),`\n`,(0,d.jsxDEV)(a.h2,{children:\"Stack in the EVM\"},void 0,!1,{fileName:\"/Users/ryan/ryan-drachenberg/content/posts/_mdx_bundler_entry_point-90eec5be-c1fb-41fa-9d5b-e22b8abc8366.mdx\",lineNumber:13,columnNumber:1},this),`\n`,(0,d.jsxDEV)(a.p,{children:\"The EVM also has a stack, which is used for evaluations and control flow. The stack has a maximum size of 1024 elements and is used for performing operations like adding, multiplying, and so on. Data can be pushed to or popped from the stack during the execution of a smart contract.\"},void 0,!1,{fileName:\"/Users/ryan/ryan-drachenberg/content/posts/_mdx_bundler_entry_point-90eec5be-c1fb-41fa-9d5b-e22b8abc8366.mdx\",lineNumber:14,columnNumber:1},this),`\n`,(0,d.jsxDEV)(a.h2,{children:\"Gas Costs\"},void 0,!1,{fileName:\"/Users/ryan/ryan-drachenberg/content/posts/_mdx_bundler_entry_point-90eec5be-c1fb-41fa-9d5b-e22b8abc8366.mdx\",lineNumber:16,columnNumber:1},this),`\n`,(0,d.jsxDEV)(a.p,{children:\"It's important to note that both memory and storage operations in the EVM come with associated gas costs. Gas is the fee required to conduct a transaction or execute a smart contract on the Ethereum network. Operations involving storage are generally more expensive than those involving memory due to the permanent nature of storage.\"},void 0,!1,{fileName:\"/Users/ryan/ryan-drachenberg/content/posts/_mdx_bundler_entry_point-90eec5be-c1fb-41fa-9d5b-e22b8abc8366.mdx\",lineNumber:17,columnNumber:1},this),`\n`,(0,d.jsxDEV)(a.h2,{children:\"Blockchain State\"},void 0,!1,{fileName:\"/Users/ryan/ryan-drachenberg/content/posts/_mdx_bundler_entry_point-90eec5be-c1fb-41fa-9d5b-e22b8abc8366.mdx\",lineNumber:19,columnNumber:1},this),`\n`,(0,d.jsxDEV)(a.p,{children:\"The overall state of the Ethereum blockchain (including all account balances, smart contract code, and smart contract storage) is stored in a data structure known as a Merkle Patricia Tree. This structure enables efficient and secure verification of the blockchain's contents.\"},void 0,!1,{fileName:\"/Users/ryan/ryan-drachenberg/content/posts/_mdx_bundler_entry_point-90eec5be-c1fb-41fa-9d5b-e22b8abc8366.mdx\",lineNumber:20,columnNumber:1},this),`\n`,(0,d.jsxDEV)(a.p,{children:\"In summary, the EVM's memory location refers to the volatile space used for temporary data storage during transaction execution, while persistent data storage is achieved through the blockchain's state, specifically in the storage associated with each smart contract. The EVM's architecture ensures efficient execution of smart contracts while maintaining the integrity and state of the Ethereum blockchain.\"},void 0,!1,{fileName:\"/Users/ryan/ryan-drachenberg/content/posts/_mdx_bundler_entry_point-90eec5be-c1fb-41fa-9d5b-e22b8abc8366.mdx\",lineNumber:22,columnNumber:1},this)]},void 0,!0,{fileName:\"/Users/ryan/ryan-drachenberg/content/posts/_mdx_bundler_entry_point-90eec5be-c1fb-41fa-9d5b-e22b8abc8366.mdx\",lineNumber:1,columnNumber:1},this)}function vr(u={}){let{wrapper:a}=u.components||{};return a?(0,d.jsxDEV)(a,Object.assign({},u,{children:(0,d.jsxDEV)(Ce,u,void 0,!1,{fileName:\"/Users/ryan/ryan-drachenberg/content/posts/_mdx_bundler_entry_point-90eec5be-c1fb-41fa-9d5b-e22b8abc8366.mdx\"},this)}),void 0,!1,{fileName:\"/Users/ryan/ryan-drachenberg/content/posts/_mdx_bundler_entry_point-90eec5be-c1fb-41fa-9d5b-e22b8abc8366.mdx\"},this):Ce(u)}var gr=vr;return mr(yr);})();\n/*! Bundled license information:\n\nreact/cjs/react-jsx-dev-runtime.development.js:\n  (**\n   * @license React\n   * react-jsx-dev-runtime.development.js\n   *\n   * Copyright (c) Facebook, Inc. and its affiliates.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *)\n*/\n;return Component;"
  },
  "_id": "posts/unlock-the-secrets-of-ethereum.mdx",
  "_raw": {
    "sourceFilePath": "posts/unlock-the-secrets-of-ethereum.mdx",
    "sourceFileName": "unlock-the-secrets-of-ethereum.mdx",
    "sourceFileDir": "posts",
    "contentType": "mdx",
    "flattenedPath": "posts/unlock-the-secrets-of-ethereum"
  },
  "type": "Post",
  "slug": "/posts/unlock-the-secrets-of-ethereum",
  "slugAsParams": "unlock-the-secrets-of-ethereum"
}